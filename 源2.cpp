#include <iostream>
#include <cmath>
#include <iomanip>
#include <fstream>

using namespace std;

const double h = 0.1;
const double k = 0.01;
const double t = 0.25;
const double e = 2.718281828;
const double pi = 3.1415926535897;
const double lambda = 1 * 1 * k / (h*h);
const unsigned iterations = t / k;
const unsigned matsize = 1 / h - 1;

double precise_func(double x, double t)
{
	return pow(e, -pi*pi*t)*sin(pi*x) + x*(1 - x);
}

double init_func(double x)
{
	return sin(pi*x) + x*(1 - x);
}

void explicit_method(double* arr)
{
	static double m = 1 - 2 * lambda;
	static double l = lambda;
	static double r = 2 * k;
	static double matA[] =
	{
		m, l, 0, 0, 0, 0, 0, 0, 0, r,
		l, m, l, 0, 0, 0, 0, 0, 0, r,
		0, l, m, l, 0, 0, 0, 0, 0, r,
		0, 0, l, m, l, 0, 0, 0, 0, r,
		0, 0, 0, l, m, l, 0, 0, 0, r,
		0, 0, 0, 0, l, m, l, 0, 0, r,
		0, 0, 0, 0, 0, l, m, l, 0, r,
		0, 0, 0, 0, 0, 0, l, m, l, r,
		0, 0, 0, 0, 0, 0, 0, l, m, r,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 1
	};
	for (unsigned register i = 0; i != iterations; ++i)
	{
		double* arrN = new double[matsize + 1];
		for (unsigned j = 0; j != matsize; ++j)
		{
			arrN[j] = 0;
		}
		for (unsigned register j = 0; j != matsize; ++j)
		{
			for (unsigned register ki = 0; ki <= matsize; ++ki)
			{
				arrN[j] += matA[j*matsize + ki] * arr[ki];
			}
		}
		arrN[matsize] = 1.0;
		for (unsigned j = 0; j <= matsize; ++j)
		{
			arr[j] = arrN[j];
		}
		delete[] arrN;
	}
}

void implicit_method(double* arr)
{
	static double invmatA[] =
	{
		0.381966001478197, 0.145898004434590, 0.0557280118255728, 0.0212860310421286, 0.00310421286031042, 0.00118255728011826, 0.000443458980044346, 0.000147819660014782, 0.0123577235772358,
		0.145898004434590, 0.437694013303769, 0.167184035476718, 0.0638580931263858, 0.0243902439024390, 0.00931263858093127, 0.00354767184035477, 0.00133037694013304, 0.000443458980044346, 0.0170731707317073,
		0.0557280118255728, 0.167184035476718, 0.445824094604582, 0.170288248337029, 0.0650406504065041, 0.0248337028824834, 0.00946045824094604, 0.00354767184035477, 0.00118255728011826, 0.0188617886178862,
		0.0212860310421286, 0.0638580931263858, 0.170288248337029, 0.447006651884701, 0.170731707317073, 0.0651884700665189, 0.0248337028824834, 0.00931263858093127, 0.00310421286031042, 0.0195121951219512,
		0.00813008130081301, 0.0243902439024390, 0.0650406504065041, 0.170731707317073, 0.447154471544715, 0.170731707317073, 0.0650406504065041, 0.0243902439024390, 0.00813008130081301, 0.0196747967479675,
		0.00310421286031042, 0.00931263858093126, 0.0248337028824834, 0.0651884700665188, 0.170731707317073, 0.447006651884701, 0.170288248337029, 0.0638580931263858, 0.0212860310421286, 0.0195121951219512,
		0.00118255728011826, 0.00354767184035477, 0.00946045824094605, 0.0248337028824834, 0.0650406504065041, 0.170288248337029, 0.445824094604582, 0.167184035476718, 0.0557280118255728, 0.0188617886178862,
		0.000443458980044346, 0.00133037694013304, 0.00354767184035477, 0.00931263858093127, 0.0243902439024390, 0.0638580931263858, 0.167184035476718, 0.437694013303769, 0.145898004434590, 0.0170731707317073,
		0.000147819660014782, 0.000443458980044346, 0.00118255728011826, 0.00310421286031042, 0.00813008130081301, 0.0212860310421286, 0.0557280118255728, 0.145898004434590, 0.381966001478197, 0.0123577235772358,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 1
	};
	for (unsigned register i = 0; i != iterations; ++i)
	{
		double* arrN = new double[matsize + 1];
		for (unsigned j = 0; j != matsize; ++j)
		{
			arrN[j] = 0;
		}
		for (unsigned register j = 0; j != matsize; ++j)
		{
			for (unsigned register ki = 0; ki <= matsize; ++ki)
			{
				arrN[j] += invmatA[j*matsize + ki] * arr[ki];
			}
		}
		arrN[matsize] = 1.0;
		for (unsigned j = 0; j <= matsize; ++j)
		{
			arr[j] = arrN[j];
		}
		delete[] arrN;
	}
}

void Crank_Nicolson_method(double* arr)
{
	static double matinvAmulB[] =
	{
		0.0717967696740596, 0.287187078696238, 0.0769515451108938, 0.0206191017473367, 0.00552486187845304, 0.00148034576647546, 0.000396521187448783, 0.000105738983319675, 2.64347458299188e-05, 1.73472347597681e-18,
		0.287187078696238, 0.148748314784953, 0.307806180443575, 0.0824764069893468, 0.0220994475138122, 0.00592138306590182, 0.00158608474979513, 0.000422955933278702, 0.000105738983319675, 3.46944695195361e-18,
		0.0769515451108938, 0.307806180443575, 0.154273176663406, 0.309286526210051, 0.0828729281767956, 0.0222051864971318, 0.00594781781173174, 0.00158608474979513, 0.000396521187448783 - 3.46944695195361e-18,
		0.0206191017473367, 0.0824764069893468, 0.309286526210051, 0.154669697850855, 0.309392265193370, 0.0828993629226255, 0.0222051864971318, 0.00592138306590182, 0.00148034576647546, 3.46944695195361e-18,
		0.00552486187845304, 0.0220994475138122, 0.0828729281767956, 0.309392265193370, 0.154696132596685, 0.309392265193370, 0.0828729281767956, 0.0220994475138122, 0.00552486187845304, 0,
		0.00148034576647546, 0.00592138306590182, 0.0222051864971318, 0.0828993629226255, 0.309392265193370, 0.154669697850855, 0.309286526210051, 0.0824764069893468, 0.0206191017473367, 3.46944695195361e-18,
		0.000396521187448783, 0.00158608474979513, 0.00594781781173174, 0.0222051864971318, 0.0828729281767956, 0.309286526210051, 0.154273176663406, 0.307806180443575, 0.0769515451108938, 0,
		0.000105738983319675, 0.000422955933278701, 0.00158608474979513, 0.00592138306590182, 0.0220994475138122, 0.0824764069893468, 0.307806180443575, 0.148748314784953, 0.287187078696238, 0,
		2.64347458299188e-05, 0.000105738983319675, 0.000396521187448783, 0.00148034576647546, 0.00552486187845304, 0.0206191017473367, 0.0769515451108938, 0.287187078696238, 0.0717967696740596, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 1
	};
	for (unsigned register i = 0; i != iterations; ++i)
	{
		double* arrN = new double[matsize + 1];
		for (unsigned j = 0; j != matsize; ++j)
		{
			arrN[j] = 0;
		}
		for (unsigned register j = 0; j != matsize; ++j)
		{
			for (unsigned register ki = 0; ki <= matsize; ++ki)
			{
				arrN[j] += matinvAmulB[j*matsize + ki] * arr[ki];
			}
		}
		arrN[matsize] = 1.0;
		for (unsigned j = 0; j <= matsize; ++j)
		{
			arr[j] = arrN[j];
		}
		delete[] arrN;
	}
}

int main(void)
{
	double* arr0 = new double[matsize + 1];
	arr0[matsize] = 1.0;
	fstream fout;
	fout << setprecision(16);

	fout.open("D:/explicit_data.txt", ios::out);
	for (unsigned register i = 0; i != matsize; ++i)
	{
		arr0[i] = init_func((i + 1)*h);
	}
	explicit_method(arr0);
	for (unsigned register i = 0; i != matsize; ++i)
	{
		double xi = (i + 1)*h;
		fout << xi << ',' << arr0[i] << ',' << precise_func(xi, t) << endl;
	}
	fout.close();

	fout.open("D:/implicit_data.txt", ios::out);
	for (unsigned register i = 0; i != matsize; ++i)
	{
		arr0[i] = init_func((i + 1)*h);
	}
	implicit_method(arr0);
	for (unsigned register i = 0; i != matsize; ++i)
	{
		double xi = (i + 1)*h;
		fout << xi << ',' << arr0[i] << ',' << precise_func(xi, t) << endl;
	}
	fout.close();

	fout.open("D:/Crank-Nicolson.txt", ios::out);
	for (unsigned register i = 0; i != matsize; ++i)
	{
		arr0[i] = init_func((i + 1)*h);
	}
	Crank_Nicolson_method(arr0);
	for (unsigned register i = 0; i != matsize; ++i)
	{
		double xi = (i + 1)*h;
		fout << xi << ',' << arr0[i] << ',' << precise_func(xi, t) << endl;
	}
	fout.close();
}
